--- Documentation/laptops/asus-laptop.txt.orig	2015-05-19 09:52:17.005001563 +0200
+++ Documentation/laptops/asus-laptop.txt	2015-05-19 10:08:59.749001573 +0200
@@ -8,8 +8,8 @@
 
  This driver provides support for extra features of ACPI-compatible ASUS laptops.
  It may also support some MEDION, JVC or VICTOR laptops (such as MEDION 9675 or
- VICTOR XP7210 for example). It makes all the extra buttons generate input
- events (like keyboards).
+ VICTOR XP7210 for example). It makes all the extra buttons generate standard
+ ACPI events that go through /proc/acpi/events and input events (like keyboards).
  On some models adds support for changing the display brightness and output,
  switching the LCD backlight on and off, and most importantly, allows you to
  blink those fancy LEDs intended for reporting mail and wireless status.
@@ -55,8 +55,8 @@
   DSDT) to me.
 
   That's all, now, all the events generated by the hotkeys of your laptop
-  should be reported via netlink events. You can check with
-  "acpi_genl monitor" (part of the acpica project).
+  should be reported in your /proc/acpi/event entry. You can check with
+  "acpi_listen".
 
   Hotkeys are also reported as input keys (like keyboards) you can check
   which key are supported using "xev" under X11.
--- Documentation/laptops/sony-laptop.txt.orig	2015-05-19 09:52:24.565001587 +0200
+++ Documentation/laptops/sony-laptop.txt	2015-05-19 10:08:59.749001573 +0200
@@ -12,10 +12,10 @@
 ------------------
 Some models report hotkeys through the SNC or SPIC devices, such events are
 reported both through the ACPI subsystem as acpi events and through the INPUT
-subsystem. See the logs of /proc/bus/input/devices to find out what those
-events are and which input devices are created by the driver.
-Additionally, loading the driver with the debug option will report all events
-in the kernel log.
+subsystem. See the logs of acpid or /proc/acpi/event and
+/proc/bus/input/devices to find out what those events are and which input
+devices are created by the driver. Additionally, loading the driver with the
+debug option will report all events in the kernel log.
 
 The "scancodes" passed to the input system (that can be remapped with udev)
 are indexes to the table "sony_laptop_input_keycode_map" in the sony-laptop.c
--- drivers/acpi/Kconfig.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/acpi/Kconfig	2015-05-19 10:08:59.750001589 +0200
@@ -88,6 +88,24 @@
 	  Thus this option is a debug option that helps to write ACPI drivers
 	  and can be used to identify ACPI code or EC firmware bugs.
 
+config ACPI_PROC_EVENT
+	bool "Deprecated /proc/acpi/event support"
+	depends on PROC_FS
+	default y
+	help
+	  A user-space daemon, acpid, typically reads /proc/acpi/event
+	  and handles all ACPI-generated events.
+
+	  These events are now delivered to user-space either
+	  via the input layer or as netlink events.
+
+	  This build option enables the old code for legacy
+	  user-space implementation.  After some time, this will
+	  be moved under CONFIG_ACPI_PROCFS, and then deleted.
+
+	  Say Y here to retain the old behaviour.  Say N if your
+	  user-space is newer than kernel 2.6.23 (September 2007).
+
 config ACPI_AC
 	tristate "AC Adapter"
 	depends on X86
--- drivers/acpi/ac.c.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/acpi/ac.c	2015-05-19 10:08:59.750001589 +0200
@@ -271,6 +271,7 @@
 			msleep(ac_sleep_before_get_state_ms);
 
 		acpi_ac_get_state(ac);
+		acpi_bus_generate_proc_event(device, event, (u32) ac->state);
 		acpi_bus_generate_netlink_event(device->pnp.device_class,
 						  dev_name(&device->dev), event,
 						  (u32) ac->state);
--- drivers/acpi/acpi_pad.c.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/acpi/acpi_pad.c	2015-05-19 10:08:59.751001594 +0200
@@ -445,6 +445,7 @@
 	switch (event) {
 	case ACPI_PROCESSOR_AGGREGATOR_NOTIFY:
 		acpi_pad_handle_notify(handle);
+		acpi_bus_generate_proc_event(device, event, 0);
 		acpi_bus_generate_netlink_event(device->pnp.device_class,
 			dev_name(&device->dev), event, 0);
 		break;
--- drivers/acpi/battery.c.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/acpi/battery.c	2015-05-19 10:11:28.752001535 +0200
@@ -1078,6 +1078,8 @@
 	if (event == ACPI_BATTERY_NOTIFY_INFO)
 		acpi_battery_refresh(battery);
 	acpi_battery_update(battery, false);
+	acpi_bus_generate_proc_event(device, event,
+	                             acpi_battery_present(battery));
 	acpi_bus_generate_netlink_event(device->pnp.device_class,
 					dev_name(&device->dev), event,
 					acpi_battery_present(battery));
--- drivers/acpi/bus.c.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/acpi/bus.c	2015-05-19 10:08:59.753001590 +0200
@@ -345,6 +345,104 @@
 }
 
 /* --------------------------------------------------------------------------
+                                Event Management
+   -------------------------------------------------------------------------- */
+
+#ifdef CONFIG_ACPI_PROC_EVENT
+static DEFINE_SPINLOCK(acpi_bus_event_lock);
+
+LIST_HEAD(acpi_bus_event_list);
+DECLARE_WAIT_QUEUE_HEAD(acpi_bus_event_queue);
+
+extern int event_is_open;
+
+int acpi_bus_generate_proc_event4(const char *device_class, const char *bus_id, u8 type, int data)
+{
+	struct acpi_bus_event *event;
+	unsigned long flags;
+
+	/* drop event on the floor if no one's listening */
+	if (!event_is_open)
+		return 0;
+
+	event = kzalloc(sizeof(struct acpi_bus_event), GFP_ATOMIC);
+	if (!event)
+		return -ENOMEM;
+
+	strcpy(event->device_class, device_class);
+	strcpy(event->bus_id, bus_id);
+	event->type = type;
+	event->data = data;
+
+	spin_lock_irqsave(&acpi_bus_event_lock, flags);
+	list_add_tail(&event->node, &acpi_bus_event_list);
+	spin_unlock_irqrestore(&acpi_bus_event_lock, flags);
+
+	wake_up_interruptible(&acpi_bus_event_queue);
+
+	return 0;
+
+}
+
+EXPORT_SYMBOL_GPL(acpi_bus_generate_proc_event4);
+
+int acpi_bus_generate_proc_event(struct acpi_device *device, u8 type, int data)
+{
+	if (!device)
+		return -EINVAL;
+	return acpi_bus_generate_proc_event4(device->pnp.device_class,
+					     device->pnp.bus_id, type, data);
+}
+
+EXPORT_SYMBOL(acpi_bus_generate_proc_event);
+
+int acpi_bus_receive_event(struct acpi_bus_event *event)
+{
+	unsigned long flags;
+	struct acpi_bus_event *entry = NULL;
+
+	DECLARE_WAITQUEUE(wait, current);
+
+
+	if (!event)
+		return -EINVAL;
+
+	if (list_empty(&acpi_bus_event_list)) {
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&acpi_bus_event_queue, &wait);
+
+		if (list_empty(&acpi_bus_event_list))
+			schedule();
+
+		remove_wait_queue(&acpi_bus_event_queue, &wait);
+		set_current_state(TASK_RUNNING);
+
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+	}
+
+	spin_lock_irqsave(&acpi_bus_event_lock, flags);
+	if (!list_empty(&acpi_bus_event_list)) {
+		entry = list_entry(acpi_bus_event_list.next,
+				   struct acpi_bus_event, node);
+		list_del(&entry->node);
+	}
+	spin_unlock_irqrestore(&acpi_bus_event_lock, flags);
+
+	if (!entry)
+		return -ENODEV;
+
+	memcpy(event, entry, sizeof(struct acpi_bus_event));
+
+	kfree(entry);
+
+	return 0;
+}
+
+#endif	/* CONFIG_ACPI_PROC_EVENT */
+
+/* --------------------------------------------------------------------------
                              Notification Handling
    -------------------------------------------------------------------------- */
 
--- drivers/acpi/button.c.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/acpi/button.c	2015-05-19 10:08:59.753001590 +0200
@@ -314,6 +314,8 @@
 					dev_name(&device->dev),
 					event, ++button->pushed);
 		}
+
+		acpi_bus_generate_proc_event(device, event, ++button->pushed);
 		break;
 	default:
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
--- drivers/acpi/event.c.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/acpi/event.c	2015-05-19 10:08:59.754001588 +0200
@@ -21,6 +21,100 @@
 #define _COMPONENT		ACPI_SYSTEM_COMPONENT
 ACPI_MODULE_NAME("event");
 
+#ifdef CONFIG_ACPI_PROC_EVENT
+/* Global vars for handling event proc entry */
+static DEFINE_SPINLOCK(acpi_system_event_lock);
+int event_is_open = 0;
+extern struct list_head acpi_bus_event_list;
+extern wait_queue_head_t acpi_bus_event_queue;
+
+static int acpi_system_open_event(struct inode *inode, struct file *file)
+{
+	spin_lock_irq(&acpi_system_event_lock);
+
+	if (event_is_open)
+		goto out_busy;
+
+	event_is_open = 1;
+
+	spin_unlock_irq(&acpi_system_event_lock);
+	return 0;
+
+      out_busy:
+	spin_unlock_irq(&acpi_system_event_lock);
+	return -EBUSY;
+}
+
+static ssize_t
+acpi_system_read_event(struct file *file, char __user * buffer, size_t count,
+		       loff_t * ppos)
+{
+	int result = 0;
+	struct acpi_bus_event event;
+	static char str[ACPI_MAX_STRING];
+	static int chars_remaining = 0;
+	static char *ptr;
+
+	if (!chars_remaining) {
+		memset(&event, 0, sizeof(struct acpi_bus_event));
+
+		if ((file->f_flags & O_NONBLOCK)
+		    && (list_empty(&acpi_bus_event_list)))
+			return -EAGAIN;
+
+		result = acpi_bus_receive_event(&event);
+		if (result)
+			return result;
+
+		chars_remaining = sprintf(str, "%s %s %08x %08x\n",
+					  event.device_class ? event.
+					  device_class : "<unknown>",
+					  event.bus_id ? event.
+					  bus_id : "<unknown>", event.type,
+					  event.data);
+		ptr = str;
+	}
+
+	if (chars_remaining < count) {
+		count = chars_remaining;
+	}
+
+	if (copy_to_user(buffer, ptr, count))
+		return -EFAULT;
+
+	*ppos += count;
+	chars_remaining -= count;
+	ptr += count;
+
+	return count;
+}
+
+static int acpi_system_close_event(struct inode *inode, struct file *file)
+{
+	spin_lock_irq(&acpi_system_event_lock);
+	event_is_open = 0;
+	spin_unlock_irq(&acpi_system_event_lock);
+	return 0;
+}
+
+static unsigned int acpi_system_poll_event(struct file *file, poll_table * wait)
+{
+	poll_wait(file, &acpi_bus_event_queue, wait);
+	if (!list_empty(&acpi_bus_event_list))
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+static const struct file_operations acpi_system_event_ops = {
+	.owner = THIS_MODULE,
+	.open = acpi_system_open_event,
+	.read = acpi_system_read_event,
+	.release = acpi_system_close_event,
+	.poll = acpi_system_poll_event,
+	.llseek = default_llseek,
+};
+#endif	/* CONFIG_ACPI_PROC_EVENT */
+
 /* ACPI notifier chain */
 static BLOCKING_NOTIFIER_HEAD(acpi_chain_head);
 
@@ -172,6 +266,9 @@
 
 static int __init acpi_event_init(void)
 {
+#ifdef CONFIG_ACPI_PROC_EVENT
+	struct proc_dir_entry *entry;
+#endif
 	int error = 0;
 
 	if (acpi_disabled)
@@ -182,6 +279,15 @@
 	if (error)
 		printk(KERN_WARNING PREFIX
 		       "Failed to create genetlink family for ACPI event\n");
+
+#ifdef CONFIG_ACPI_PROC_EVENT
+	/* 'event' [R] */
+	entry = proc_create("event", S_IRUSR, acpi_root_dir,
+			    &acpi_system_event_ops);
+	if (!entry)
+		return -ENODEV;
+#endif
+
 	return 0;
 }
 
--- drivers/acpi/processor_driver.c.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/acpi/processor_driver.c	2015-05-19 10:08:59.755001586 +0200
@@ -89,17 +89,21 @@
 		acpi_processor_ppc_has_changed(pr, 1);
 		if (saved == pr->performance_platform_limit)
 			break;
+		acpi_bus_generate_proc_event(device, event,
+					pr->performance_platform_limit);
 		acpi_bus_generate_netlink_event(device->pnp.device_class,
 						  dev_name(&device->dev), event,
 						  pr->performance_platform_limit);
 		break;
 	case ACPI_PROCESSOR_NOTIFY_POWER:
 		acpi_processor_cst_has_changed(pr);
+		acpi_bus_generate_proc_event(device, event, 0);
 		acpi_bus_generate_netlink_event(device->pnp.device_class,
 						  dev_name(&device->dev), event, 0);
 		break;
 	case ACPI_PROCESSOR_NOTIFY_THROTTLING:
 		acpi_processor_tstate_has_changed(pr);
+		acpi_bus_generate_proc_event(device, event, 0);
 		acpi_bus_generate_netlink_event(device->pnp.device_class,
 						  dev_name(&device->dev), event, 0);
 		break;
--- drivers/acpi/sbs.c.orig	2015-10-01 21:40:00.578631507 +0200
+++ drivers/acpi/sbs.c	2015-10-01 21:43:20.414635894 +0200
@@ -618,8 +618,14 @@
 
 	if (sbs->charger_exists) {
 		acpi_ac_get_present(sbs);
-		if (sbs->charger_present != saved_charger_state)
+		if (sbs->charger_present != saved_charger_state) {
+#ifdef CONFIG_ACPI_PROC_EVENT
+			acpi_bus_generate_proc_event4(ACPI_AC_CLASS, ACPI_AC_DIR_NAME,
+			                              ACPI_SBS_NOTIFY_STATUS,
+			                              sbs->charger_present);
+#endif
 			kobject_uevent(&sbs->charger->dev.kobj, KOBJ_CHANGE);
+		}
 	}
 
 	if (sbs->manager_present) {
@@ -631,6 +637,12 @@
 			acpi_battery_read(bat);
 			if (saved_battery_state == bat->present)
 				continue;
+#ifdef CONFIG_ACPI_PROC_EVENT
+			acpi_bus_generate_proc_event4(ACPI_BATTERY_CLASS,
+			                              bat->name,
+			                              ACPI_SBS_NOTIFY_STATUS,
+			                              bat->present);
+#endif
 			kobject_uevent(&bat->bat->dev.kobj, KOBJ_CHANGE);
 		}
 	}
--- drivers/acpi/thermal.c.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/acpi/thermal.c	2015-05-19 10:08:59.756001585 +0200
@@ -759,6 +759,7 @@
 	else
 		return 0;
 
+	acpi_bus_generate_proc_event(tz->device, type, 1);
 	acpi_bus_generate_netlink_event(tz->device->pnp.device_class,
 					dev_name(&tz->device->dev), type, 1);
 
@@ -966,12 +967,14 @@
 	case ACPI_THERMAL_NOTIFY_THRESHOLDS:
 		acpi_thermal_trips_update(tz, ACPI_TRIPS_REFRESH_THRESHOLDS);
 		acpi_thermal_check(tz);
+		acpi_bus_generate_proc_event(device, event, 0);
 		acpi_bus_generate_netlink_event(device->pnp.device_class,
 						  dev_name(&device->dev), event, 0);
 		break;
 	case ACPI_THERMAL_NOTIFY_DEVICES:
 		acpi_thermal_trips_update(tz, ACPI_TRIPS_REFRESH_DEVICES);
 		acpi_thermal_check(tz);
+		acpi_bus_generate_proc_event(device, event, 0);
 		acpi_bus_generate_netlink_event(device->pnp.device_class,
 						  dev_name(&device->dev), event, 0);
 		break;
--- drivers/acpi/video.c.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/acpi/video.c	2015-05-19 10:21:55.481001558 +0200
@@ -1472,6 +1472,7 @@
 	switch (event) {
 	case ACPI_VIDEO_NOTIFY_SWITCH:	/* User requested a switch,
 					 * most likely via hotkey. */
+		acpi_bus_generate_proc_event(device, event, 0);
 		keycode = KEY_SWITCHVIDEOMODE;
 		break;
 
@@ -1479,16 +1480,20 @@
 					 * connector. */
 		acpi_video_device_enumerate(video);
 		acpi_video_device_rebind(video);
+		acpi_bus_generate_proc_event(device, event, 0);
 		keycode = KEY_SWITCHVIDEOMODE;
 		break;
 
 	case ACPI_VIDEO_NOTIFY_CYCLE:	/* Cycle Display output hotkey pressed. */
+		acpi_bus_generate_proc_event(device, event, 0);
 		keycode = KEY_SWITCHVIDEOMODE;
 		break;
 	case ACPI_VIDEO_NOTIFY_NEXT_OUTPUT:	/* Next Display output hotkey pressed. */
+		acpi_bus_generate_proc_event(device, event, 0);
 		keycode = KEY_VIDEO_NEXT;
 		break;
 	case ACPI_VIDEO_NOTIFY_PREV_OUTPUT:	/* previous Display output hotkey pressed. */
+		acpi_bus_generate_proc_event(device, event, 0);
 		keycode = KEY_VIDEO_PREV;
 		break;
 
@@ -1540,22 +1545,27 @@
 	switch (event) {
 	case ACPI_VIDEO_NOTIFY_CYCLE_BRIGHTNESS:	/* Cycle brightness */
 		brightness_switch_event(video_device, event);
+		acpi_bus_generate_proc_event(device, event, 0);
 		keycode = KEY_BRIGHTNESS_CYCLE;
 		break;
 	case ACPI_VIDEO_NOTIFY_INC_BRIGHTNESS:	/* Increase brightness */
 		brightness_switch_event(video_device, event);
+		acpi_bus_generate_proc_event(device, event, 0);
 		keycode = KEY_BRIGHTNESSUP;
 		break;
 	case ACPI_VIDEO_NOTIFY_DEC_BRIGHTNESS:	/* Decrease brightness */
 		brightness_switch_event(video_device, event);
+		acpi_bus_generate_proc_event(device, event, 0);
 		keycode = KEY_BRIGHTNESSDOWN;
 		break;
 	case ACPI_VIDEO_NOTIFY_ZERO_BRIGHTNESS:	/* zero brightness */
 		brightness_switch_event(video_device, event);
+		acpi_bus_generate_proc_event(device, event, 0);
 		keycode = KEY_BRIGHTNESS_ZERO;
 		break;
 	case ACPI_VIDEO_NOTIFY_DISPLAY_OFF:	/* display device off */
 		brightness_switch_event(video_device, event);
+		acpi_bus_generate_proc_event(device, event, 0);
 		keycode = KEY_DISPLAY_OFF;
 		break;
 	default:
--- drivers/char/sonypi.c.orig	2015-05-19 09:54:26.702001600 +0200
+++ drivers/char/sonypi.c	2015-05-19 10:08:59.758001586 +0200
@@ -876,6 +876,11 @@
 	if (useinput)
 		sonypi_report_input_event(event);
 
+#ifdef CONFIG_ACPI
+	if (sonypi_acpi_device)
+		acpi_bus_generate_proc_event(sonypi_acpi_device, 1, event);
+#endif
+
 	kfifo_in_locked(&sonypi_device.fifo, (unsigned char *)&event,
 			sizeof(event), &sonypi_device.fifo_lock);
 	kill_fasync(&sonypi_device.fifo_async, SIGIO, POLL_IN);
--- drivers/pci/hotplug/acpiphp_ibm.c.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/pci/hotplug/acpiphp_ibm.c	2015-05-19 10:22:59.590001579 +0200
@@ -259,6 +259,7 @@
 
 	if (subevent == 0x80) {
 		pr_debug("%s: generating bus event\n", __func__);
+		acpi_bus_generate_proc_event(note->device, note->event, detail);
 		acpi_bus_generate_netlink_event(note->device->pnp.device_class,
 						  dev_name(&note->device->dev),
 						  note->event, detail);
--- drivers/platform/x86/asus-laptop.c.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/platform/x86/asus-laptop.c	2015-05-19 10:08:59.759001587 +0200
@@ -1541,6 +1541,7 @@
 
 	/* TODO Find a better way to handle events count. */
 	count = asus->event_count[event % 128]++;
+	acpi_bus_generate_proc_event(asus->device, event, count);
 	acpi_bus_generate_netlink_event(asus->device->pnp.device_class,
 					dev_name(&asus->device->dev), event,
 					count);
--- drivers/platform/x86/eeepc-laptop.c.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/platform/x86/eeepc-laptop.c	2015-05-19 10:08:59.760001587 +0200
@@ -1230,6 +1230,7 @@
 	if (event > ACPI_MAX_SYS_NOTIFY)
 		return;
 	count = eeepc->event_count[event % 128]++;
+	acpi_bus_generate_proc_event(device, event, count);
 	acpi_bus_generate_netlink_event(device->pnp.device_class,
 					dev_name(&device->dev), event,
 					count);
--- drivers/platform/x86/fujitsu-laptop.c.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/platform/x86/fujitsu-laptop.c	2015-05-19 10:08:59.761001587 +0200
@@ -748,6 +748,8 @@
 				else
 					set_lcd_level(newb);
 			}
+			acpi_bus_generate_proc_event(fujitsu->dev,
+				ACPI_VIDEO_NOTIFY_INC_BRIGHTNESS, 0);
 			keycode = KEY_BRIGHTNESSUP;
 		} else if (oldb > newb) {
 			if (disable_brightness_adjust != 1) {
@@ -756,6 +758,8 @@
 				else
 					set_lcd_level(newb);
 			}
+			acpi_bus_generate_proc_event(fujitsu->dev,
+				ACPI_VIDEO_NOTIFY_DEC_BRIGHTNESS, 0);
 			keycode = KEY_BRIGHTNESSDOWN;
 		}
 		break;
--- drivers/platform/x86/panasonic-laptop.c.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/platform/x86/panasonic-laptop.c	2015-05-19 10:24:11.302001708 +0200
@@ -473,6 +473,8 @@
 					result & 0xf, 0x80, false);
 	}
 
+	acpi_bus_generate_proc_event(pcc->device, HKEY_NOTIFY, result);
+
 	if (!sparse_keymap_report_event(hotk_input_dev,
 					result & 0xf, result & 0x80, false))
 		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
--- drivers/platform/x86/sony-laptop.c.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/platform/x86/sony-laptop.c	2015-05-19 10:08:59.763001586 +0200
@@ -1288,6 +1288,9 @@
 		ev_type = HOTKEY;
 		sony_laptop_report_input_event(real_ev);
 	}
+
+	acpi_bus_generate_proc_event(sony_nc_acpi_device, ev_type, real_ev);
+
 	acpi_bus_generate_netlink_event(sony_nc_acpi_device->pnp.device_class,
 			dev_name(&sony_nc_acpi_device->dev), ev_type, real_ev);
 }
@@ -4628,6 +4631,7 @@
 
 found:
 	sony_laptop_report_input_event(device_event);
+	acpi_bus_generate_proc_event(dev->acpi_dev, 1, device_event);
 	sonypi_compat_report_event(device_event);
 	return IRQ_HANDLED;
 }
--- drivers/platform/x86/thinkpad_acpi.c.orig	2015-03-06 23:53:42.000000000 +0100
+++ drivers/platform/x86/thinkpad_acpi.c	2015-05-19 10:08:59.765001585 +0200
@@ -2283,6 +2283,10 @@
 static void tpacpi_hotkey_send_key(unsigned int scancode)
 {
 	tpacpi_input_send_key_masked(scancode);
+	if (hotkey_report_mode < 2) {
+		acpi_bus_generate_proc_event(ibm_hotkey_acpidriver.device,
+				0x80, TP_HKEY_EV_HOTKEY_BASE + scancode);
+	}
 }
 
 static void hotkey_read_nvram(struct tp_nvram_state *n, const u32 m)
@@ -3824,6 +3828,13 @@
 				  "event happened to %s\n", TPACPI_MAIL);
 		}
 
+		/* Legacy events */
+		if (!ignore_acpi_ev &&
+		    (send_acpi_ev || hotkey_report_mode < 2)) {
+			acpi_bus_generate_proc_event(ibm->acpi->device,
+						     event, hkey);
+		}
+
 		/* netlink events */
 		if (!ignore_acpi_ev && send_acpi_ev) {
 			acpi_bus_generate_netlink_event(
--- include/acpi/acpi_bus.h.orig	2015-03-06 23:53:42.000000000 +0100
+++ include/acpi/acpi_bus.h	2015-05-19 10:08:59.766001586 +0200
@@ -443,6 +443,15 @@
 static inline bool acpi_bus_can_wakeup(acpi_handle handle) { return false; }
 #endif
 
+#ifdef CONFIG_ACPI_PROC_EVENT
+int acpi_bus_generate_proc_event(struct acpi_device *device, u8 type, int data);
+int acpi_bus_generate_proc_event4(const char *class, const char *bid, u8 type, int data);
+int acpi_bus_receive_event(struct acpi_bus_event *event);
+#else
+static inline int acpi_bus_generate_proc_event(struct acpi_device *device, u8 type, int data)
+	{ return 0; }
+#endif
+
 void acpi_scan_lock_acquire(void);
 void acpi_scan_lock_release(void);
 void acpi_lock_hp_context(void);
